from flask import jsonifyfrom flask import Response as FlaskResponsefrom werkzeug.wrappers import Response as WerkzeugResponsedef json_response(function):    """Decorator function to return json response for view functions.    Args:        function: A function that will be wrapped with context.    """    def wrapper(*args, **kwargs):        """Decorate function here.        Args:            *args: Arguments of the function.            **kwargs: Keyword arguments of the function.        Returns:            :obj:`function`: Wrapped function.        """        result = function(*args, **kwargs)        if isinstance(result, tuple):            first_arg = jsonify(result[0])            return (first_arg, *result[1:])        elif isinstance(result, (FlaskResponse, WerkzeugResponse)):            return result        else:            return jsonify(result)    # To avoid naming conflicts.    wrapper.__name__ = function.__name__    return wrapperdef celery_exception_handler(*exceptions):    """Decorator function for catching exceptions.    This decorator function gets a function and put it into a try-catch    and handles responses.    """    def decorator(function):        """Inner decorator function.        Args:            function: The function will be decorated.        Returns:            Decorated function.        """        def wrapper(*args, **kwargs):            """Function wrapper.            Args:                *args: Arguments of wrapped function.                **kwargs: Keyword arguments of wrapped function.            """            try:                response = function(*args, **kwargs)            except exceptions as e:                response = {"status": "failure", "message": str(e)}                args[0].retry(countdown=3 ** args[0].request.retries)            return response        # NOTE: Flask needs unique function names for request        # handler functions. When we wrap a function it names become wrapper        # that is above function. So we change wrapper function name        # by given function name in order to solve this problem.        wrapper.__name__ = function.__name__        return wrapper    return decorator