from _md5 import md5from flask import jsonifyfrom flask import Response as FlaskResponsefrom werkzeug.wrappers import Response as WerkzeugResponsefrom application.rests.mongo import insert_one, update_onedef json_response(function):    """Decorator function to return json response for view functions.    Args:        function: A function that will be wrapped with context.    """    def wrapper(*args, **kwargs):        """Decorate function here.        Args:            *args: Arguments of the function.            **kwargs: Keyword arguments of the function.        Returns:            :obj:`function`: Wrapped function.        """        result = function(*args, **kwargs)        if isinstance(result, tuple):            first_arg = jsonify(result[0])            return (first_arg, *result[1:])        elif isinstance(result, (FlaskResponse, WerkzeugResponse)):            return result        else:            return jsonify(result)    # To avoid naming conflicts.    wrapper.__name__ = function.__name__    return wrapperdef celery_exception_handler(*exceptions):    """Decorator function for catching exceptions.    This decorator function gets a function and put it into a try-catch    and handles responses.    """    def decorator(function):        """Inner decorator function.        Args:            function: The function will be decorated.        Returns:            Decorated function.        """        def wrapper(*args, **kwargs):            """Function wrapper.            Args:                *args: Arguments of wrapped function.                **kwargs: Keyword arguments of wrapped function.            """            _id = md5(                f'{function.__name__}-{args}-{kwargs}'.encode("utf-8")            ).hexdigest()            insert_one("tasks", {                "id": _id,                "function__name__": function.__name__,                "wrapper__name__": wrapper.__name__,                "decorator__name__": decorator.__name__,                "exceptions": ",".join([str(e) for e in exceptions]),                "args": list(map(str, args)),                "kwargs": {str(key): str(val) for key, val in kwargs},                "status": "started"            })            try:                response = function(*args, **kwargs)                status = "finished_ok"            except exceptions as e:                response = {"status": "failure", "message": str(e)}                args[0].retry(countdown=3 ** args[0].request.retries)                status = "finished_fail"            update_one(                "tasks",                {                    "filter": {"id": {"$eq": _id}},                    "update": {"$set": {                        "status": status,                        "response": str(response)                    }}                }            )            return response        # NOTE: Flask needs unique function names for request        # handler functions. When we wrap a function it names become wrapper        # that is above function. So we change wrapper function name        # by given function name in order to solve this problem.        wrapper.__name__ = function.__name__        return wrapper    return decorator